# Notes
## Main Design Decisions
Tujuan utama dari refactoring ini adalah untuk mengubah implementasi yang sudah ada menjadi arsitektur yang bersih dan mudah dipelihara, mengikuti prinsip-prinsip pemrograman berorientasi objek dan pemisahan tanggung jawab. Saya merestrukturisasi kode menjadi empat lapisan yang terpisah: services (embedding, storage, workflow), model (kontrak API), appication logic (class RagApplication), dan endpoint API (route FastAPI). Masing-masing program memiliki tanggung jawab tunggal yang jelas. Perubahan paling signifikan adalah menghilangkan semua state global dengan mengenkapsulasi fungsionalitas ke dalam kelas yang menggunakan injeksi dependensi secara eksplisit. Misalnya, class RagWorkflow kini menerima instance DocumentStore dan EmbeddingService melalui konstruktornya, bukan bergantung pada variabel global. Hal ini membuat dependensi menjadi eksplisit, memudahkan pengujian unit dengan objek mock, dan memungkinkan adanya beberapa instance workflow dengan konfigurasi yang berbeda. Saya juga memperkenalkan kelas dasar abstrak untuk DocumentStore untuk memfasilitasi polimorfisme antara implementasi Qdrant dan in-memory, memastikan antarmuka yang sama berfungsi dengan mulus pada kedua backend. Untuk mepersiapakan program production-ready, saya mencoba menambahkan file container yang dapat di build dan up secara langsung. Hal ini dapat mempermudah apabila program yang dibuat akan dicoba ditempat lain tanpa khawatir akan perbedaan dependensi.
## Trade-off Considered
Salah satu trade-off utama yang saya pertimbangkan adalah tingkat abstraksi pada lapisan storage. Saya memilih untuk mengimplementasikan kelas dasar abstrak (DocumentStore) dengan dua implementasi konkret (QdrantDocumentStore dan InMemoryDocumentStore). Meskipun ini menambah kompleksitas dibandingkan dengan satu implementasi tunggal, hal ini memberikan fleksibilitas krusial untuk beralih antara backend storage tanpa perlu memodifikasi kode yang bergantung. Alternatifnya ialah sebuah kelas storage dengan logika kondisionalâ€”akan lebih sederhana pada awalnya tetapi akan melanggar Prinsip open/closed dan membuat pengujian menjadi lebih sulit. Mengingat kode asli sudah menangani skenario Qdrant dan storage dalam memori, abstraksi ini dibenarkan dan sebenarnya menyederhanakan logika alur kerja dengan menyembunyikan detail implementasi storage.
## How this improve Maintanability
Versi yang telah direfaktorisasi ini secara signifikan meningkatkan kemudahan pemeliharaan dalam beberapa aspek. Pertama, perubahan dibatasi pada area tertentu: jika perlu memodifikasi logika embedding, kita hanya perlu mengubah embedding.py; jika penyimpanan perlu diperbarui, hanya storage.py yang diubah. Kedua, pengujian menjadi lebih mudah: setiap service dapat diuji secara mandiri dengan dependensi yang dimock, dan kelas RagApplication dapat diuji tanpa perlu menjalankan instance Qdrant yang sebenarnya. Ketiga, kode menjadi mudah dibaca dimana nama kelas yang jelas, dependensi yang eksplisit, dan petunjuk tipe membuat arsitektur sistem langsung dimengerti oleh pengembang baru. Selanjutnya saya memperbaiki function pencarian RAG yang salah dimana function rag search tidak sesuai dengan versi rag_client yang sekarang sehingga saya memperbaikinya menjadi query_point. Terakhir, memperluas fungsionalitas menjadi sederhana: menambahkan penyedia embedding baru hanya memerlukan pembuatan kelas baru dengan antarmuka yang sama, dan menambahkan endpoint API baru hanya memerlukan penambahan metode ke RagApplication dan route FastAPI yang sesuai.