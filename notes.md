# Notes
## Main Design Decisions
The main goal of this refactoring is to change the existing implementation into a clean and maintainable architecture, following object-oriented programming principles and separation of concerns. I restructured the code into four separate layers: services (embedding, storage, workflow), model (API contract), application logic (RagApplication class), and API endpoint (FastAPI route). Each program has a clear single responsibility.
The most significant change is the removal of all global state by encapsulating functionality into classes that explicitly use dependency injection. For example, the RagWorkflow class now receives instances of DocumentStore and EmbeddingService through its constructor, rather than relying on global variables. This makes dependencies explicit, facilitates unit testing with mock objects, and allows for multiple workflow instances with different configurations. I also introduced an abstract base class for DocumentStore to facilitate polymorphism between Qdrant and in-memory implementations, ensuring that the same interface works seamlessly on both backends.
## Trade-offs Considered
One of the main trade-offs I considered was the level of abstraction in the storage layer. I chose to implement an abstract base class (DocumentStore) with two concrete implementations (QdrantDocumentStore and InMemoryDocumentStore). Although this adds complexity compared to a single implementation, it provides crucial flexibility to switch between storage backends without modifying dependent code. The alternative would be a storage class with conditional logicâ€”it would be simpler initially but would violate the open/closed principle and make testing more difficult. Given that the original code already handles both Qdrant and in-memory storage scenarios, this abstraction is justified and actually simplifies the workflow logic by hiding storage implementation details.
## How this improves maintainability
This refactored version significantly improves maintainability in several ways. First, changes are limited to specific areas: if the embedding logic needs to be modified, only embedding.py needs to be changed; if storage needs to be updated, only storage.py is changed. Second, testing becomes easier: each service can be tested independently with mocked dependencies, and the RagApplication class can be tested without needing to run an actual Qdrant instance. Third, the code becomes easy to read where clear class names, explicit dependencies, and type hints make the system architecture immediately understandable to new developers. Next, I fixed the incorrect RAG search function, where the rag search function was not compatible with the current version of rag_client, so I fixed it to query_point. Finally, extending functionality becomes simple: adding a new embedding provider only requires creating a new class with the same interface, and adding a new API endpoint only requires adding a method to RagApplication and the corresponding FastAPI route.